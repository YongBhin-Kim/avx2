# 암호분석경진대회 3번문제
# (RSA d 찾기)

C = 374015834710561043810344051134135
n = 98639350158287747956171614024858003106737929785723376047985588489903225031675238942280563373940905701931651170379361219551278894213021434648783114473246721338107200738833103695814346217200966617698677137725683746838186561756004241774294434212453862492176950276330700287348945941127494562176214125995218765677
M = 8684345636908686698383058753930515845376216074491905095625386038921316376845905096948974184280037158397773209920391529649784574906985754450477350014610356222003127212466169135522169279492231954962510144676909892095883819057606351964935618910468692572435658048566378696492965708241737271579660195263078472751

def decrypt(d, c, n):
    key = d
    ciphertext = c
    return pow(ciphertext, key, n)

fault_injection = [ 5, 11, 18, 24, 30, 37, 43, 51, 57, 63, 70, 78, 84, 90, 98, 105, 112, 120, 125, 131, 137, 144, 150, 156, 161, 169, 176, 180, 187, 193, 201, 205, 212, 220, 228, 235, 239, 246, 252, 258, 265, 269, 277, 283, 290, 295, 301, 307, 311, 318, 326, 330, 337, 345, 353, 360, 365, 370, 377, 383, 389, 397, 405, 409, 413, 421, 429, 433, 441, 446, 454, 461, 468, 476, 483, 490, 497, 504, 510, 517, 524, 531, 538, 546, 551, 559, 562, 569, 577, 584, 590, 596, 599, 606, 609, 617, 624, 631, 638, 642, 648, 653, 658, 662, 670, 676, 681, 689, 693, 700, 708, 716, 723, 730, 738, 746, 753, 758, 763, 769, 778, 784, 790, 796, 804, 812, 819, 826, 831, 838, 844, 850, 858, 865, 869, 876, 883, 890, 897, 903, 910, 917, 925, 932, 939, 945, 950, 954, 959, 963, 969, 976, 983, 989, 993, 998, 1005, 1010, 1016, 1021 ]

# Read given error plaintext
f = open('fault_message.txt', 'r')
fault_messages = f.readlines()
for i in range(len(fault_messages)):
    fault_messages[i] = int(fault_messages[i])

d = 0

msb=1024

# d guessing down to fault_messages
print("Guessing d : ")
for i in range(len(fault_messages)-1, -1, -1):                  # 159 to 0
    guessing_bits = msb-fault_injection[i]                  # guessing해야하는 비트 수
    for j in range(1<<guessing_bits):                           # guessing하는 비트 내의 숫자들
        temp_d = d | (j<<fault_injection[i])                    # temp_d = d | (j<<1021) # 현재까지 추측한 d와 새로 예상해야 하는 구간의 비트를 합쳐서 새로 예상할 d를 뽑아냄
        if decrypt(temp_d, C, n) == fault_messages[i]:      # decrypt with guessing sk == error message
            d = temp_d
            print(".",end='')
            break
    msb = fault_injection[i]
    
# d guessing last
for i in range(1<<5):
    temp_d = d | i
    if decrypt(temp_d, C, n) == M:
        d = temp_d
print("\nFind d : " + str(d))



# # ####### 추측 결과
# d = 20646880471663202869566232833254529298232005139090182227234482855554762057837876738486729150918127842578976620157530512684505605548228146550986568874742485155127686821951511580046551849124741181496278463050206509803234280344064874556689401791224664167519960699855949176247703409096031887519334691774606527337
# # 검증
# # M == C^d mod n
print(M == decrypt(d, C, n))
